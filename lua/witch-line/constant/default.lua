---@type Component[]|string[]
return {
	"mode",
	"file.filename",
	-- require("witch-line.components.file").Icon,

	-- {
	-- 	event = "BufEnter",
	-- 		{
	-- 			padding = { left = 1, right = 0 },
	-- 			styles = function(configs, context, shared, self)
	-- 				local icon, color_icon, filename = self.static.get(configs)
	-- 				return { fg = color_icon }
	-- 			end,
	-- 			update = function(configs, context, shared, self)
	-- 				local icon, color_icon, filename = self.static.get(configs)
	-- 				return icon
	-- 			end,
	-- 		},
	-- 		{
	-- 			update = function(configs, context, shared, self)
	-- 				local icon, color_icon, filename = self.static.get(configs)
	-- 				return filename
	-- 			end,
	-- 		},
	-- 		{
	-- 			styles = function()
	-- 				if not api.nvim_buf_get_option(0, "modifiable") or api.nvim_buf_get_option(0, "readonly") then
	-- 					return { fg = colors.red }
	-- 				elseif api.nvim_buf_get_option(0, "modified") then
	-- 					return { fg = "Statusline" }
	-- 				end
	-- 			end,
	-- 			padding = { left = 0, right = 1 },
	-- 			update = function()
	-- 				if not api.nvim_buf_get_option(0, "modifiable") or api.nvim_buf_get_option(0, "readonly") then
	-- 					return ""
	-- 				elseif api.nvim_buf_get_option(0, "modified") then
	-- 					return ""
	-- 				end
	-- 				return ""
	-- 			end,
	-- 		},
	-- 	},
	-- 	{
	-- 		name = "git-branch",
	-- 		user_event = "GitSignsUpdate",
	-- 		configs = {
	-- 			icon = "",
	-- 		},
	-- 		styles = { fg = colors.pink },
	-- 		update = function(configs, context)
	-- 			local branch = ""
	-- 			local git_dir = fn.finddir(".git", ".;")
	-- 			if git_dir ~= "" then
	-- 				local head_file = io.open(git_dir .. "/HEAD", "r")
	-- 				if head_file then
	-- 					local content = head_file:read("*all")
	-- 					head_file:close()
	-- 					-- branch name  or commit hash
	-- 					branch = content:match("ref: refs/heads/(.-)%s*$") or content:sub(1, 7) or ""
	-- 				end
	-- 			end
	-- 			return branch ~= "" and configs.icon .. " " .. branch or ""
	-- 		end,
	-- 		condition = function()
	-- 			return api.nvim_buf_get_option(0, "buflisted")
	-- 		end,
	-- 	},
	-- 	{
	-- 		name = "git-diff",
	-- 		event = "BufWritePost",
	-- 		user_event = "GitSignsUpdate",
	-- 		configs = {
	-- 			added = "",
	-- 			changed = "",
	-- 			removed = "",
	-- 		},
	-- 		{
	-- 			styles = { fg = "DiffAdd" },
	-- 			update = function(configs)
	-- 				local git_status = vim.b.gitsigns_status_dict
	-- 				return git_status.added and git_status.added > 0 and configs.added .. " " .. git_status.added
	-- 					or ""
	-- 			end,
	-- 		},
	-- 		{
	-- 			styles = { fg = "DiffChange" },
	-- 			update = function(configs)
	-- 				local git_status = vim.b.gitsigns_status_dict
	-- 				return git_status.changed
	-- 						and git_status.changed > 0
	-- 						and configs.changed .. " " .. git_status.changed
	-- 					or ""
	-- 			end,
	-- 		},
	-- 		{
	-- 			styles = { fg = "DiffDelete" },
	-- 			update = function(configs)
	-- 				local git_status = vim.b.gitsigns_status_dict
	-- 				return git_status.removed
	-- 						and git_status.removed > 0
	-- 						and configs.removed .. " " .. git_status.removed
	-- 					or ""
	-- 			end,
	-- 		},
	-- 		condition = function()
	-- 			return vim.b.gitsigns_status_dict ~= nil and vim.o.columns > 70
	-- 		end,
	-- 	},
	-- },

	-- "%=",
	-- {
	-- 	styles = {
	-- 		fg = "DiagnosticHint",
	-- 	},
	-- 	update = function(configs)
	-- 		local count = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.HINT })
	-- 		return count > 0 and configs.HINT .. " " .. count or ""
	-- 	end,
	-- },

	-- {
	-- 	name = "lsps-formatters",
	-- 	event = { "LspAttach", "LspDetach", "BufWritePost", "BufEnter" },
	-- 	styles = { fg = colors.magenta },
	-- 	update = function()
	-- 		local buf_clients = vim.lsp.buf_get_clients()
	-- 		local server_names = {}
	-- 		local has_null_ls = false
	-- 		local ignore_lsp_servers = {
	-- 			["null-ls"] = true,
	-- 			["copilot"] = true,
	-- 		}

	-- 		for _, client in pairs(buf_clients) do
	-- 			local client_name = client.name
	-- 			if not ignore_lsp_servers[client_name] then
	-- 				server_names[#server_names + 1] = client_name
	-- 			end
	-- 		end

	-- 		if package.loaded["null-ls"] then
	-- 			local null_ls = nil
	-- 			has_null_ls, null_ls = pcall(require, "null-ls")

	-- 			if has_null_ls then
	-- 				local buf_ft = api.nvim_buf_get_option(0, "filetype")
	-- 				local null_ls_methods = {
	-- 					null_ls.methods.DIAGNOSTICS,
	-- 					null_ls.methods.DIAGNOSTICS_ON_OPEN,
	-- 					null_ls.methods.DIAGNOSTICS_ON_SAVE,
	-- 					null_ls.methods.FORMATTING,
	-- 				}

	-- 				local get_null_ls_sources = function(methods, name_only)
	-- 					local sources = require("null-ls.sources")
	-- 					local available_sources = sources.get_available(buf_ft)

	-- 					methods = type(methods) == "table" and methods or { methods }

	-- 					-- methods = nil or {}
	-- 					if #methods == 0 then
	-- 						if name_only then
	-- 							return vim.tbl_map(function(source)
	-- 								return source.name
	-- 							end, available_sources)
	-- 						end
	-- 						return available_sources
	-- 					end

	-- 					local source_results = {}

	-- 					for _, source in ipairs(available_sources) do
	-- 						for _, method in ipairs(methods) do
	-- 							if source.methods[method] then
	-- 								if name_only then
	-- 									source_results[#source_results + 1] = source.name
	-- 								else
	-- 									source_results[#source_results + 1] = source
	-- 								end
	-- 								break
	-- 							end
	-- 						end
	-- 					end

	-- 					return source_results
	-- 				end

	-- 				local null_ls_builtins = get_null_ls_sources(null_ls_methods, true)
	-- 				vim.list_extend(server_names, null_ls_builtins)
	-- 			end
	-- 		end

	-- 		if package.loaded["conform"] then
	-- 			local has_conform, conform = pcall(require, "conform")
	-- 			if has_conform then
	-- 				vim.list_extend(
	-- 					server_names,
	-- 					vim.tbl_map(function(formatter)
	-- 						return formatter.name
	-- 					end, conform.list_formatters(0))
	-- 				)
	-- 				if has_null_ls then
	-- 					server_names = fn.uniq(server_names)
	-- 				end
	-- 			end
	-- 		end

	-- 		return #server_names > 0 and table.concat(server_names, ", ") or "NO LSP, FORMATTER  "
	-- 	end,

	-- 	condition = function()
	-- 		return vim.o.columns > 70
	-- 	end,
	-- },
	-- {
	-- 	name = "copilot-loading",
	-- 	user_event = "SttuslineCopilotLoad",
	-- 	configs = {
	-- 		icons = {
	-- 			normal = "",
	-- 			error = "",
	-- 			warning = "",
	-- 			inprogress = { "", "󰪞", "󰪟", "󰪠", "󰪢", "󰪣", "󰪤", "󰪥" },
	-- 		},
	-- 		fps = 3, -- should be 3 - 5
	-- 	},
	-- 	init = function(configs)
	-- 		local nvim_exec_autocmds = api.nvim_exec_autocmds
	-- 		local schedule = vim.schedule
	-- 		local buf_get_option = api.nvim_buf_get_option
	-- 		local timer = uv.new_timer()
	-- 		local curr_inprogress_index = 0
	-- 		local icons = configs.icons
	-- 		local status = ""

	-- 		api.nvim_create_autocmd("InsertEnter", {
	-- 			once = true,
	-- 			desc = "Init copilot status",
	-- 			callback = function()
	-- 				local cp_api_ok, cp_api = pcall(require, "copilot.api")
	-- 				if cp_api_ok then
	-- 					cp_api.register_status_notification_handler(function(data)
	-- 						schedule(function()
	-- 							-- don't need to get status when in TelescopePrompt
	-- 							if buf_get_option(0, "buftype") == "prompt" then
	-- 								return
	-- 							end
	-- 							status = string.lower(data.status or "")

	-- 							if status == "inprogress" then
	-- 								timer:start(
	-- 									0,
	-- 									math.floor(1000 / configs.fps),
	-- 									vim.schedule_wrap(function()
	-- 										nvim_exec_autocmds(
	-- 											"User",
	-- 											{ pattern = "SttuslineCopilotLoad", modeline = false }
	-- 										)
	-- 									end)
	-- 								)
	-- 								return
	-- 							end
	-- 							timer:stop()
	-- 							nvim_exec_autocmds("User", { pattern = "SttuslineCopilotLoad", modeline = false })
	-- 						end)
	-- 					end)
	-- 				end
	-- 			end,
	-- 		})

	-- 		return {
	-- 			get_icon = function()
	-- 				if status == "inprogress" then
	-- 					curr_inprogress_index = curr_inprogress_index < #icons.inprogress
	-- 							and curr_inprogress_index + 1
	-- 						or 1
	-- 					return icons.inprogress[curr_inprogress_index]
	-- 				else
	-- 					curr_inprogress_index = 0
	-- 					return icons[status] or status or ""
	-- 				end
	-- 			end,
	-- 			check_status = function()
	-- 				local cp_client_ok, cp_client = pcall(require, "copilot.client")
	-- 				if not cp_client_ok then
	-- 					status = "error"
	-- 					require("sttusline.util.notify").error("Cannot load copilot.client")
	-- 					return
	-- 				end

	-- 				local copilot_client = cp_client.get()
	-- 				if not copilot_client then
	-- 					status = "error"
	-- 					return
	-- 				end

	-- 				local cp_api_ok, cp_api = pcall(require, "copilot.api")
	-- 				if not cp_api_ok then
	-- 					status = "error"
	-- 					require("sttusline.util.notify").error("Cannot load copilot.api")
	-- 					return
	-- 				end

	-- 				cp_api.check_status(copilot_client, {}, function(cserr, status_copilot)
	-- 					if cserr or not status_copilot.user or status_copilot.status ~= "OK" then
	-- 						status = "error"
	-- 						return
	-- 					end
	-- 				end)
	-- 			end,
	-- 		}
	-- 	end,
	-- 	update = function(_, init_state)
	-- 		if package.loaded["copilot"] then
	-- 			init_state.check_status()
	-- 		end
	-- 		return init_state.get_icon()
	-- 	end,
	-- },
	-- {
	-- 	event = { "BufEnter", "WinEnter" },
	-- 	{
	-- 		name = "indent",
	-- 		styles = { fg = colors.cyan },
	-- 		update = function()
	-- 			return "Tab: " .. api.nvim_buf_get_option(0, "shiftwidth") .. ""
	-- 		end,
	-- 	},
	-- 	{
	-- 		name = "encoding",
	-- 		configs = {
	-- 			["utf-8"] = "󰉿",
	-- 			["utf-16"] = "󰊀",
	-- 			["utf-32"] = "󰊁",
	-- 			["utf-8mb4"] = "󰊂",
	-- 			["utf-16le"] = "󰊃",
	-- 			["utf-16be"] = "󰊄",
	-- 		},
	-- 		styles = { fg = colors.yellow },
	-- 		update = function(configs)
	-- 			local enc = vim.bo.fenc ~= "" and vim.bo.fenc or vim.o.enc
	-- 			return configs[enc] or enc
	-- 		end,
	-- 	},
	-- },
	-- {
	-- 	event = { "CursorMoved", "CursorMovedI" },
	-- 	{
	-- 		name = "pos-cursor",
	-- 		styles = { fg = colors.fg },
	-- 		update = function()
	-- 			local pos = api.nvim_win_get_cursor(0)
	-- 			return pos[1] .. ":" .. pos[2]
	-- 		end,
	-- 	},
	-- 	{
	-- 		name = "pos-cursor-progress",
	-- 		configs = {
	-- 			chars = { "_", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█" },
	-- 		},
	-- 		padding = 0,
	-- 		styles = { fg = colors.orange },
	-- 		update = function(configs)
	-- 			local line = fn.line
	-- 			return configs.chars[math.ceil(line(".") / line("$") * #configs.chars)] or ""
	-- 		end,
	-- 	},
	-- },
}
